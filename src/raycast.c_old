uint8_t	get_color(t_game *game, t_raycast *r)
{
	uint8_t	*color;
	int index;

	// index = (texHeight * r->tex_y + r->tex_x) * 4; // Assuming RGBA format (4 bytes per pixel)
	index = (texHeight * r->tex_y + r->tex_x); // Assuming RGBA format (4 bytes per pixel)
	color = 0;
	if (r->side == 0 && r->ray_dirx > 0)
    	color = (uint8_t *)(game->no_texture->pixels + index * game->no_texture->bytes_per_pixel);
	else if (r->side == 0 && r->ray_dirx < 0)
    	color = (uint8_t *)(game->so_texture->pixels + index * game->so_texture->bytes_per_pixel);
	else if (r->side == 1 && r->ray_dirx > 0)
    	color = (uint8_t *)(game->e_texture->pixels + index * game->e_texture->bytes_per_pixel);
	else if (r->side == 1 && r->ray_dirx < 0)
    	color = (uint8_t *)(game->w_texture->pixels + index * game->w_texture->bytes_per_pixel);
	return (color[0] << 24 | color[1] << 16 | color[2] << 8 | color[3]);
}



uint8_t	get_color(t_game *game, t_raycast *r)
{
	uint8_t	color;
	int index;

	index = (texHeight * r->tex_y + r->tex_x) * 4; // Assuming RGBA format (4 bytes per pixel)
	color = 0;
	if (r->side == 0 && r->ray_dirx > 0)
    	color = *(uint32_t *)(game->no_texture->pixels + index);
		// color = *(game->no_texture->pixels + (texHeight * r->tex_y + r->tex_x));
	else if (r->side == 0 && r->ray_dirx < 0)
    	color = *(uint32_t *)(game->so_texture->pixels + index);
		// color = *(game->so_texture->pixels + (texHeight * r->tex_y + r->tex_x));
	else if (r->side == 1 && r->ray_dirx > 0)
    	color = *(uint32_t *)(game->e_texture->pixels + index);
		// color = *(game->e_texture->pixels + (texHeight * r->tex_y + r->tex_x));
	else if (r->side == 1 && r->ray_dirx < 0)
    	color = *(uint32_t *)(game->w_texture->pixels + index);
		// color = *(game->w_texture->pixels + (texHeight * r->tex_y + r->tex_x));
	return (color);
}


void update_pixelmap(t_game *game, int x)
{
	t_raycast	*r;
	int			y;

	r = &game->r;
	r->dir = ft_get_direction(r);
    //x coordinate on the texture
    // if(side == 0 && rayDirX > 0) texX = texWidth — texX — 1; //touches x axis (south)
    // if(side == 1 && rayDirY < 0) texX = texWidth — texX — 1; //touches y axis (west)
	r->tex_x = (int)(r->wall_x * texWidth);
	if ((r->side == 0 && r->ray_dirx < 0) || (r->side == 1 && r->ray_diry > 0))
		r->tex_x = texWidth - r->tex_x - 1;
	// How much to increase the texture coordinate per screen pixel
	r->step = 1.0 * texHeight / r->line_height;
	// Starting texture coordinate pos = texpos
	r->pos = (r->draw_start - HEIGHT / 2 + r->line_height / 2) * r->step;
	y = r->draw_start;
	while (y < r->draw_end)
	{
		// Cast the texture coordinate to integer, and mask with (texHeight — 1) in case of overflow
		r->tex_y= (int)r->pos & (texHeight - 1);
		r->pos += r->step;
		// r->color = get_color(game,r);
		r->color = game->no_texture->pixels[texHeight * r->tex_y + r->tex_x];

		if(r->side == 1)
			r->color = (r->color >> 1) & 8355711;
		if (r->color > 0)				// your pixel map (int** in this case)
			mlx_put_pixel(game->img, x, y, r->color);
			// r->pixel_map[r->draw_start][x] = r->color;
		// r->draw_start++;
		y++;
	}
}